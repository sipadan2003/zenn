---
title: "JavaでのMethod Sigunatureとは"
emoji: "🌊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Java"]
published: true
---

# JavaでのMethod Signatureとは

Java における Method Signature とは何でしょう？Java SE 18 Editionの2つの仕様を見比べます。

Java Language Specification（JLS）の [8.4.2 Method Signature](https://docs.oracle.com/javase/specs/jls/se18/html/jls-8.html#jls-8.4.2) によると、2つのメソッドの「メソッド名」と「引数の型」が同じであれば、これらのメソッドは同じとみなされます。

> Two methods or constructors, M and N, have the same signature if they have the same name, the same type parameters (if any), and, after adapting the formal parameter types of N to the type parameters of M, the same formal parameter types.

一方、Java Vitual Machine Specification の [4.7.9.1. Signatures](https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.7.9.1) では、「引数の型」、「復帰値」および「スローする例外」の3つで判別するとのことです。なんと、「メソッド名」を含めていません。

> A method signature for any method or constructor declaration which is either generic, or has a type variable or parameterized type as the return type or a formal parameter type, or has a type variable in a throws clause, or any combination thereof.

意外に思われるかもしれませんが、バイトコードがどのような作りになっているかを紐解けば、案外、これらの仕様差に納得がいくだろうと思います。

まず、呼び出される側のクラスのJavaソース。 `methodA` メソッドを持つクラスです。

```Java: I.java
class I {
	static void methodA(String s) {
		System.out.println(s);
	}
}
```

次に呼び出す側です。これらのクラスの違いは、 `methodA` の登場回数です。前者は3回、後者は1回のみです。

```Java: A.java
class A {
	static final String S = "methodA";

	public static void main(String[] args){
		I.methodA("methodA");
	}
}
```

```Java: B.java
class B {
	public static void main(String[] args){
		I.methodA("a");
	}
}
```

`A` と `B` クラスのバイトコードを `javap -verbose <className>.class` でアセンブルした結果を、抜粋します。

``` : A.class
  :
Constant pool:
    :
   #2 = String             #18            // methodA
   #3 = Methodref          #19.#20        // O.methodA:(Ljava/lang/String;)V
    :
  #18 = Utf8               methodA
  #19 = Class              #23            // O
  #20 = NameAndType        #18:#24        // methodA:(Ljava/lang/String;)V
    :
  #24 = Utf8               (Ljava/lang/String;)V
  :
```

``` : B.class
  :
   #3 = Methodref          #16.#17        // O.methodA:(Ljava/lang/String;)V
    :
  #16 = Class              #20            // O
  #17 = NameAndType        #21:#22        // methodA:(Ljava/lang/String;)V
    :
  #20 = Utf8               O
  #21 = Utf8               methodA
  #22 = Utf8               (Ljava/lang/String;)V
```

注目点が2つあります。

1. 両クラスとも `methodA` という文字列を1箇所のみで定義している
2. 呼び出し先の `NameAndType` の参照先が、次のように異なる
   - Aクラスでは、#18、#24と離れている
   - Bクラスでは、#21、#22とくっついている

`methodA` 文字列が1箇所のみで定義されているのも、呼び出し先のメソッド情報を「メソッド名」と「引数・復帰値」の2つに分けるのも、 `Constant pool` の資源を最小化するためであることが伺えます。結果、Javaアプリケーション実行時のJavaヒープの節約にもつながるわけです。

以上から、Java VM Language Specification では Method Signature からメソッド名を除外していることに合点がいくでしょうか？